---
layout: post
author: AU-turtledragon
title: Final Project & Reflection
---

## First thing's first... The code:
<iframe src="https://trinket.io/embed/python3/d124c745c2" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>

## And the process that brought it about:
I've joined the MSIS program with pracical very goals in mind.  Sure, I have a few loftier ones here and there about "fixing" UT's outdated admin workflows and revolutionizing our student services information technology platforms.  But, for the most part, I really just want to supercharge my own toolbox and develop ways to automate some of my more repetitive processes and bring a bit mroe consistency and order to certain parts of my job that feel uncomfortably reliant on neer perfect data entry/migration and the my own brain's ability to keep track of complicated puzzles that are constantly shifting.  I know being vague, but it's not because I don't want to discuss one particular thing. Rather this feeling permeates a whole host of my responsibilities - so many of which it seems could be just a bit more stable and consistent if knew how to properly streamline and automate them with code that nobody else seems willing or able to write for me. Why should I need to manually comb over two or three years worth of notes and records just to figure out whose turn it ought to be to teach a certain class?  Why is there not a simple way to email only the specific subset of full and part-time faculty who are actually teaching classes for us **right now**, as opposed to sending teaching-specific reminders out to our entire faculty-staff listserv—thereby increasing the likelihood of it being ignored; not to mention the fact that various adjuncts aren't even on it in the first place?  Why am I still manually coming over historical scheduling data every time an accrediting body asks us for a report of our recent curriculum patterns and fluctuations?  We know what sort of criteria they're gonna ask us about, so why can't I just produce the answers with a simple keystroke or two? These are the kinds of questions that brought me to this class.  As such, I couldn't wait for an opportunity to start applying a little of what I've been learning to my work in any small way I could.  And these rusty old Class Manager data dumps I so often find myself wrestiling with via Excel seemeed like a perfect way to get started.  

Choosing a project so directly tied to my day-to-day certainly presented some benefits just in terms of my prior familiarity with and access to the data itself. Likewise, I already knew a few things I might like to do with it. In retrospect, however, i might have had a bit better luck focusing on the specifics of the assignment itself had I less vested interest in it.  Long story short, I've been so anxious for so long to hunker down and tinker with some of this stuff that I found it difficult to reel it in and just treat it like homework. And, by wanting so badly to make something-or at least get a foundation started-that I could actually put to regular use in the near future, I denied myself the chance to just kinda play with the numbers a bit.  Make a few semicomplicated data comparisons and draw up some charts and whatnot even if the stats they refer to aren't particularly meaningful to me.  You know, just let it be an exercise.  If it were that, I think I might have had an easier time just pinning down a few modest coding goals and set down a plan to knock em down. Instead, I feel like I spent much of the first 2 or 3 weeks of this final project season noodling around. It was clear from my initial project proposal that I knew what I wanted to work with and had pretty clear reasons why, but my specific targets were far from specific. I spent way too much time just sort of testing out what I've learned on the data, trusting that something would surface from those experiments and I would bundle it all up and check off all the boxes and Bob's my uncle. To be fair to myself, I suppose it did turn out ok in the end.  I didn't produce anything all that exciting, but I did manage to tick all those boxes (I think) and I honestly think I will actually refer back to it now and again as an actual work reference. In fact, just a day or two ago, I had to send out grade report deadline reminders to all our currently active instructors and compiling the appropriate email addresses and pasting them into my email client took all of 3 seconds! You seriously have no idea how tedious that simple little task has been otherwise.  ..Ok, so maybe my approach here was fine and I should stop being so critical of myself.  I suppose I'm actually kinda happy with what I pulled together, and the prospect of building it out a bit more in the future.  More than anything, I just think my nerves would've benefited from a more structured and evenly paced working plan.  If I had to do it over again, I would most certainly spend more time with that initial proposal process and set down much more specific goalposts along with a more consistent regimen of micro targets to meet along the way each day.  Dr. Hauser has been preaching that sort of approach since day one, but only now do I truly get it. There were at least a couple of times along the way when I specifically sat down with one—and only one—key component to nail down. Tackling those minor pieces and then immediately putting it away for awhile felt infinitely more satisfying than any of the late night binge sessions after which I hardly even remembered what I had accomplished.  Obsessively hunkering down and "staying in the zone" is kinda more how I roll by default.  And, in some instances, I guess that's served me well—especially when it comes to writing essays and whatnot. But, the technocreative process of coding feels a bit different.  I've definitely learned over the last week that my mind really does handle it alot better in smaller doses and with breaks.  What can I say? I guess I had to learn it my own hard way. We're all here to learn aftereall, and that exactly what I did in this case.    

## Ok, so enough about my suboptimal process...
As far as the coding itself goes, I found this to be an immensely challenging and rewarding process.  I'm too old to really care much about "making the grade", so I kind of decided to let those chips fall where they may and instead really just embrace the opportunity for a semester review of sorts.  An isolated Runestone problem here or there was one thing, but starting from nothing but a densely populated .txt file full of surprise inconsistencies and having to find my way through it all on my own was something else entirely. Consequently, many of the details that either blew right by me or just failed to properly stick came into tighter focus out of the sheer necessity of having a problem that needed solving. My brain definitely responds better to that sort of thing. The thing about the weekly assigned exercises is that they're part of a prescribed weekly topic.  Which is to say we already know what's needed for the answer, we just just have to figure out how the details work.  Which of course is part of the process of learning a new tool.  But, the more challenging part is just knowing you have a problem to solve and having to identify which tool to go at it with.  And when it comes to Python—at least as a beginner—the challenge also becomes just remembering what all the tools were that we even covered!  I for one made a deliberate effort to stick with the tools that we learned in class almost exclusively for my final project.  I understand that part of the process is also branching out and getting to know add-on modules etc.  But, there’s also a level of helpful shortcuttiness there that I didn’t want to rely on.  I really wanted to think through every little piece and just make whatever I was doing work one way or another. Consequently, I found myself almost taking a whole tour of our class from start to present in my thought processes.  I realized somewhat late in the process that I was clearly uncomfortable with dictionaries.  I seemed to be doing everything else I could come up with to avoid them.  Not intentionally, mind you.  I just clearly didn’t have a strong enough grasp on how to maneuver them that I would even reach for that tool intuitively.  Instead, much of how I was combing through my data in the earlier stages of this project was to conduct a lot of iterative line reads and even parsing out data from one .txt document out to another.  It wasn’t until after talking with Dr. Hauser about some Trinket lag that I realized the odd and decidedly Un-Pythonic system I had drifted into.  From then on, I made a point to focus much more of my work going forward around dictionaries.  Since I’d already written some other bits that were working ok, I didn’t turn _everything upside down, but certainly all the parts that involved writing and querying additional .txt files. 

And thus we get into the biggest hurdles in this whole final project process.  And this is actually a refrain I heard many times from others in class—how the heck do dictionaries work?  Having forced myself to get to know them more over the last couple of weeks, I’m certainly way more in tune with them now than ever before.  And I’m actually quite comfortable with packing them up.  In fact, I seem to have a knack for building 3+ level nested dictionaries at this point. So often, that just seems to make the most sense.  Although I wonder if I’m trying to make them serve more of a database style purpose than they’re really built for.  In any case, the headaches come when it’s time to traverse those deeply nested dictionaries and extract specific values.  Even more complicated is when I need to print a nested key and value separately.  I’ve spent countless hours going over lessons and discussion boards, but all I get from them is enough little odd scraps that I can piece together for another round of trial and error until I return an output that’s close enough.  The good news is that so far, I’m generally able to get what I need out of them.  I just never quite know how I’m doing it.  As such, I continue to tiptoe around the dictionaries.  Always carrying this nagging feeling that when I do use them, I’m doing so in the least Pythonic way possible.  If I could do this class over again, I would definitely insist we spend more time on dictionaries and really get to the root of it.  Likewise, it’s still just never quite clicked what the real benefits are for lists vs tuples.  I just need some real world experience with them.  I need a scenario where only a tuple will do the trick properly.  As of yet, I just haven’t come across a time that I’m aware of when a list or a half-baked dictionary didn’t do the trick for whatever I needed.  But I’m digressing a bit.  

## Wrapping it up...
I realize I haven’t really spoked at all about any specific pieces of code this time around that have baffled me or opened my eyes, etc.  I think I’ve proven in the past to be fairly forthcoming about that kind of stuff.  But, this time around, I just can’t think of any specific bits or strategies that shook me too much either positively or negatively.  More than anything, this process felt more like a true disciplinary practice than I had experienced in the past.  For the first time since this class started, I really came to feel like I’m speaking fluent Python.  In code of course, I mean.  I’m still pretty rusty when it comes to speaking _about_ Python.  But, speaking Python itself now feels much more natural.  I’ve got a ton to learn still to be sure.  But, feel oriented now.  I know my bearings, and where to go if I want to dig deeper into this or that.  And I’m confident that this is only the beginning of my exploration into this language and probably a handful of others before too long.  It’s frustrating being a novice anything. But, it’s liberating when it clicks.  And throughout this process, the one major shift that I’ve observed is the amount of time I spend clickity clackiting away on an idea without copying syntax from a notebook or checking with someone online.  More often than not, I just let Python tell me if it works or not.  And boooy does Python like to tell me stuff. 

Anyway, the whole class has been an eye opening process, and I’ve enjoyed it.  And the final project—through the highs and lows—really has been the congealing moment for me that Dr. Hauser had previously advertised.  I might have a few minor points of disagreement with the road we travelled this semester, but I’m pretty happy with where I’ve landed with this material.  
_If I can only get a handle on traversing these dang nested nested dictionaries!_
